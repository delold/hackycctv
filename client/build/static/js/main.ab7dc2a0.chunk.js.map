{"version":3,"sources":["routes/Home/Home.module.css","components/Scrobber/Scrobber.module.css","utils/dataProvider.ts","utils/constants.ts","components/RefreshImg.tsx","routes/Home/Home.tsx","components/HLSPlayer.tsx","utils/vibrateDecorator.ts","components/Slider.tsx","components/Scrobber/Scrobber.tsx","routes/Camera/Camera.tsx","App.tsx","index.tsx"],"names":["module","exports","provider","createContext","streams","HOST","window","localStorage","getItem","location","hostname","API_URL","COLORS","MAX_LENGTH","RefreshImg","src","alt","props","useState","Date","now","session","setSession","useEffect","interval","setInterval","clearInterval","Home","className","styles","list","Consumer","map","key","name","color","to","item","header","headerContent","style","backgroundColor","video","HLSPlayer","ref","useRef","timer","hls","videoRef","current","source","Hls","isSupported","loadSource","attachMedia","on","Events","MANIFEST_PARSED","setTimeout","play","clearTimeout","pause","destroy","autoPlay","muted","playsInline","vibrateDecorator","callback","navigator","vibrate","err","args","Slider","callbackRef","onDrag","onDragEnd","onWheel","onWheelEnd","canvasRef","bind","useGesture","event","call","useLayoutEffect","animationId","valueOffset","Math","floor","value","userOffset","draw","canvas","parentElement","ctx","getContext","parentRect","getBoundingClientRect","width","height","shift","moment","shiftedNow","clone","add","startDayX","min","diff","startOf","xFrom","xTo","viewOffset","lineWidth","strokeStyle","beginPath","moveTo","max","lineTo","closePath","stroke","drawLine","endOf","drawDayBoundedLine","onScroll","onScrollEnd","handleScroll","delta","handleScrollEnd","tick","requestAnimationFrame","cancelAnimationFrame","css","formatTime","time","absTime","abs","seconds","minutes","hours","days","result","unshift","toFixed","padStart","sign","join","Scrobber","setCurrent","nextTimer","getMilliseconds","useTimer","scrollShift","setScrollShift","delay","visible","setVisible","show","hide","useVisibleTimer","callbacks","onChange","commitShift","newShift","sliderChange","timeChange","newValue","split","Number","parseInt","past","subtract","dateChange","milliseconds","contentShift","date","minRangeRounded","maxRangeRounded","minDate","maxDate","main","opacity","onTouchStart","onMouseMove","top","back","viewBox","fill","xmlns","d","info","stream","timeline","center","timewrapper","onClick","timeoffset","live","pill","margin","cover","e","target","format","type","valueAsDate","calendar","Camera","state","from","showTools","generateUrl","baseUrl","params","push","ceil","length","newProps","this","setState","url","find","Component","App","setStreams","fetch","then","a","json","data","index","Provider","id","exact","path","component","render","match","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.ab7dc2a0.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"heading\":\"Home_heading__X9S2V\",\"item\":\"Home_item__1BfZ_\",\"header\":\"Home_header__2ZfpZ\",\"headerContent\":\"Home_headerContent__X_p_L\",\"color\":\"Home_color__mpilC\",\"name\":\"Home_name__1YdXf\",\"video\":\"Home_video__1Zmyl\",\"list\":\"Home_list__3jIXi\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"main\":\"Scrobber_main__2LuF3\",\"timeline\":\"Scrobber_timeline__2jotj\",\"center\":\"Scrobber_center__3yVBq\",\"timewrapper\":\"Scrobber_timewrapper__2nkoy\",\"timeoffset\":\"Scrobber_timeoffset__29YLh\",\"live\":\"Scrobber_live__38HNF\",\"pill\":\"Scrobber_pill__1rtDH\",\"margin\":\"Scrobber_margin__2S6hy\",\"cover\":\"Scrobber_cover__3LxDf\",\"time\":\"Scrobber_time__32A7e\",\"calendar\":\"Scrobber_calendar__B20XD\",\"top\":\"Scrobber_top__3RLJx\",\"back\":\"Scrobber_back__36HQY\",\"info\":\"Scrobber_info__ZStHx\",\"name\":\"Scrobber_name__33Nnb\",\"color\":\"Scrobber_color__2b0sF\"};","import { createContext } from \"react\"\n\nconst provider = createContext({ streams: [] })\nexport default provider\n","const HOST = window.localStorage.getItem(\"host\") || window.location.hostname\nconst PORT = 80\n\nexport const API_URL = `http://${HOST}:${PORT}`\nexport const COLORS = [\n  \"#EB5757\",\n  \"#F2994A\",\n  \"#F2C94C\",\n  \"#219653\",\n  \"#6FCF97\",\n  \"#2F80ED\",\n  \"#2D9CDB\",\n  \"#56CCF2\",\n  \"#9B51E0\",\n]\n\nexport const MAX_LENGTH = 7 * 24 * 60 * 60\n","import { useEffect, useState } from \"react\"\n\nexport function RefreshImg({\n  src,\n  alt,\n  ...props\n}: {\n  src: string | null\n  [rest: string]: any\n}) {\n  const [session, setSession] = useState(Date.now())\n  useEffect(() => {\n    const interval = window.setInterval(\n      () => void setSession(Date.now()),\n      15 * 1000\n    )\n    return () => void window.clearInterval(interval)\n  }, [])\n\n  return <img src={`${src}?q=${session}`} alt={alt} {...props} />\n}\n","import React from \"react\"\nimport DataProvider from \"../../utils/dataProvider\"\n\nimport styles from \"./Home.module.css\"\nimport { API_URL } from \"utils/constants\"\nimport { NavLink } from \"react-router-dom\"\nimport { RefreshImg } from \"../../components/RefreshImg\"\n\nexport default function Home() {\n  return (\n    <div>\n      <div className={styles.list}>\n        <DataProvider.Consumer>\n          {({ streams }) =>\n            streams.map(({ key, name, color }) => (\n              <NavLink to={`/camera/${key}`} className={styles.item}>\n                <section className={styles.header}>\n                  <div className={styles.headerContent}>\n                    <h2 className={styles.name}>{name}</h2>\n                    <span\n                      className={styles.color}\n                      style={{ backgroundColor: color }}\n                    ></span>\n                  </div>\n                </section>\n                <div className={styles.video}>\n                  <RefreshImg src={`${API_URL}/frame/${key}`} alt={name} />\n                </div>\n              </NavLink>\n            ))\n          }\n        </DataProvider.Consumer>\n      </div>\n    </div>\n  )\n}\n","import { useEffect, useRef } from \"react\"\nimport Hls from \"hls.js\"\n\nexport function HLSPlayer(props: { source: string }) {\n  const ref = useRef<HTMLVideoElement | null>(null)\n\n  useEffect(() => {\n    let timer: number\n    let videoRef = ref.current\n    let hls: Hls | undefined\n\n    if (props.source && videoRef) {\n      if (Hls.isSupported()) {\n        hls = new Hls()\n        hls.loadSource(props.source)\n        hls.attachMedia(videoRef)\n        hls.on(Hls.Events.MANIFEST_PARSED, () => {\n          timer = window.setTimeout(() => void videoRef?.play(), 300)\n        })\n      } else {\n        videoRef.src = props.source\n        timer = window.setTimeout(() => void videoRef?.play(), 300)\n      }\n    }\n\n    return () => {\n      clearTimeout(timer)\n      videoRef?.pause?.()\n      hls?.destroy?.()\n    }\n  }, [props.source])\n\n  return <video ref={ref} autoPlay muted playsInline />\n}","export const vibrateDecorator = (callback: ((...args: any) => any) | undefined | null) => {\n  if (!callback) return undefined\n  return (...args: any): any => {\n    try {\n      navigator.vibrate(200)\n    } catch (err) { }\n    return callback?.(...args)\n  }\n}\n","/** @jsxImportSource @emotion/react */\nimport { css } from \"@emotion/react\"\nimport { useRef, useLayoutEffect } from \"react\"\nimport moment from \"moment\"\nimport { GestureHandlersPartial, useGesture } from \"react-use-gesture\"\n\nimport { MAX_LENGTH } from \"utils/constants\"\n\nexport const Slider = (props: {\n  value: number\n  color: string\n  onScroll?: (shift: number) => any\n  onScrollEnd?: (shift: number) => any\n}) => {\n  const callbackRef = useRef<GestureHandlersPartial>({\n    onDrag: () => {},\n    onDragEnd: () => {},\n    onWheel: () => {},\n    onWheelEnd: () => {},\n  })\n\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const bind = useGesture({\n    onWheel: (event) => {\n      callbackRef.current.onWheel?.(event)\n    },\n    onWheelEnd: (event: any) => {\n      callbackRef.current.onWheelEnd?.(event)\n    },\n    onDrag: (event) => {\n      callbackRef.current.onDrag?.(event)\n    },\n    onDragEnd: (event: any) => {\n      callbackRef.current.onDragEnd?.(event)\n    },\n  })\n\n  useLayoutEffect(() => {\n    let animationId: number\n    // the idea: we don't need to specify the day, it should be resolved by itself.\n    // just make sure we don't draw outside the canvas\n\n    // offset of the slider caused by value\n    const valueOffset = -Math.floor(props.value / 1000)\n\n    // offset set temporarily during scrolling\n    let userOffset = 0\n\n    const draw = (canvas: HTMLCanvasElement | null) => {\n      if (!canvas || !canvas.parentElement) return\n      const ctx = canvas.getContext(\"2d\")\n      if (!ctx) return\n\n      const parentRect = canvas.parentElement.getBoundingClientRect()\n      canvas.width = parentRect.width\n      canvas.height = parentRect.height\n\n      // draws the line, receving arguments as px, not relative to time\n      const drawLine = (xFrom: number, xTo: number, viewOffset: number = 0) => {\n        const { width, height } = canvas.getBoundingClientRect()\n\n        ctx.lineWidth = 10\n        ctx.strokeStyle = props.color\n\n        ctx.beginPath()\n        ctx.moveTo(Math.min(width, Math.max(0, xFrom + viewOffset)), height / 2)\n        ctx.lineTo(Math.min(width, Math.max(0, xTo + viewOffset)), height / 2)\n        ctx.closePath()\n        ctx.stroke()\n      }\n\n      // hide progress bar when necessary\n      const drawDayBoundedLine = (shift: number) => {\n        const { width } = canvas.getBoundingClientRect()\n\n        const now = moment()\n        const shiftedNow = now.clone().add(shift, \"seconds\")\n        const startDayX = Math.min(\n          MAX_LENGTH,\n          now.diff(shiftedNow.clone().startOf(\"day\"), \"second\")\n        )\n        const endDayX = Math.max(\n          0,\n          now.diff(shiftedNow.clone().endOf(\"day\"), \"second\")\n        )\n\n        // invert direction, as we want to line to act as a timeline\n        drawLine(-(endDayX + shift), -(startDayX + shift), width / 2)\n      }\n\n      drawDayBoundedLine(valueOffset + userOffset)\n    }\n\n    const tick = () => {\n      draw(canvasRef.current)\n      animationId = window.requestAnimationFrame(tick)\n    }\n\n    const onScroll = props.onScroll\n    const onScrollEnd = props.onScrollEnd\n\n    const handleScroll = (delta: number) => {\n      userOffset = delta\n\n      // limit userOffset to be in range of <-MAX_LENGTH_IN_SECONDS, 0>, as userOffset is negative in nature\n      // (valueOffset + userOffset) <= 0 && (valueOffset + userOffset) >= -MAX_LENGTH_IN_SECONDS\n      userOffset = Math.min(\n        -valueOffset,\n        Math.max(-MAX_LENGTH - valueOffset, userOffset)\n      )\n\n      // onScroll assumes offset in ms\n      onScroll?.(-(valueOffset + userOffset) * 1000)\n    }\n\n    const handleScrollEnd = () => {\n      onScrollEnd?.(-(valueOffset + userOffset) * 1000)\n    }\n\n    callbackRef.current = {\n      onDrag: (event) => handleScroll(-event.delta[0]),\n      onWheel: (event: any) => handleScroll(event.delta[0] || -event.delta[1]),\n      onDragEnd: () => handleScrollEnd(),\n      onWheelEnd: () => handleScrollEnd(),\n    }\n\n    tick()\n\n    return () => {\n      if (animationId) window.cancelAnimationFrame(animationId)\n    }\n  }, [props.value, props.color, props.onScrollEnd, props.onScroll])\n\n  return (\n    <div\n      css={css`\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        cursor: all-scroll;\n\n        height: 5em;\n      `}\n    >\n      <canvas\n        css={css`\n          position: absolute;\n          top: 0;\n          bottom: 0;\n          left: 0;\n          right: 0;\n        `}\n        ref={canvasRef}\n        height={100}\n        {...bind()}\n      />\n    </div>\n  )\n}\n\nexport default Slider\n","import React, { useRef, useLayoutEffect, useState, useEffect } from \"react\"\nimport moment from \"moment\"\n\nimport styles from \"./Scrobber.module.css\"\nimport { NavLink } from \"react-router-dom\"\n\nimport { MAX_LENGTH } from \"utils/constants\"\nimport { vibrateDecorator } from \"utils/vibrateDecorator\"\nimport { Slider } from \"components/Slider\"\n\nconst formatTime = (time: number) => {\n  const absTime = Math.abs(time)\n\n  const seconds = Math.floor(absTime / 1000) % 60\n  const minutes = Math.floor(absTime / 1000 / 60) % 60\n  const hours = Math.floor(absTime / 1000 / 60 / 60) % 24\n  const days = Math.floor(absTime / 1000 / 60 / 60 / 24)\n\n  let result = []\n  if (seconds > 0 || minutes > 0 || hours > 0) {\n    result.unshift(`${seconds.toFixed(0).padStart(2, \"0\")}s`)\n  }\n\n  if (minutes > 0 || hours > 0) {\n    result.unshift(`${minutes.toFixed(0).padStart(2, \"0\")}m`)\n  }\n  if (hours > 0) {\n    result.unshift(`${hours.toFixed(0).padStart(2, \"0\")}h`)\n  }\n\n  if (days > 0) {\n    result.unshift(`${days}d`)\n  }\n\n  return `${Math.sign(time) < 0 ? \"-\" : \"\"}${result.join(\" \")}`\n}\n\nconst useTimer = () => {\n  const [current, setCurrent] = useState(Date.now())\n  useLayoutEffect(() => {\n    let timer: number\n\n    const tick = () => {\n      const now = Date.now()\n      const nextTimer = Math.max(1000 - new Date(now).getMilliseconds(), 0)\n      setCurrent(now)\n\n      window.clearTimeout(timer)\n      timer = window.setTimeout(tick, nextTimer)\n    }\n    tick()\n\n    return () => void window.clearTimeout(timer)\n  }, [])\n\n  return current\n}\n\nconst useVisibleTimer = (delay = 1000) => {\n  const [visible, setVisible] = useState(true)\n  const show = useRef<() => void>(() => setVisible(true))\n  const hide = useRef<() => void>(() => setVisible(false))\n\n  useEffect(() => {\n    let timer: number\n\n    hide.current = () => {\n      window.clearTimeout(timer)\n      setVisible(false)\n    }\n\n    show.current = () => {\n      window.clearTimeout(timer)\n      setVisible(true)\n      timer = window.setTimeout(hide.current, delay)\n    }\n\n    show.current()\n\n    return () => void window.clearTimeout(timer)\n  }, [delay])\n\n  return { visible, show, hide }\n}\n\nexport function Scrobber(props: {\n  onChange: (shift: number) => void\n  value: number\n  stream: {\n    key: string\n    name: string\n    color: string\n  }\n}) {\n  const current = useTimer()\n  const [scrollShift, setScrollShift] = useState<number | null>(null)\n  const { visible, show } = useVisibleTimer(10 * 1000)\n\n  const callbacks = useRef<{\n    sliderChange?: ((shift: number) => void) | undefined\n    timeChange?: ((value: string) => void) | undefined\n    dateChange?: ((value: Date | null) => void) | undefined\n  }>({})\n\n  useEffect(() => {\n    const onChange = props.onChange\n    const value = props.value\n\n    function commitShift(newShift: number) {\n      setScrollShift(null)\n      onChange(Math.max(0, Math.min(MAX_LENGTH * 1000, newShift)))\n    }\n\n    callbacks.current.sliderChange = vibrateDecorator(commitShift)\n\n    callbacks.current.timeChange = vibrateDecorator((newValue: string) => {\n      const [hours, minutes] = newValue\n        .split(\":\")\n        .map((item) => Number.parseInt(item, 10))\n      const now = moment()\n      const past = now\n        .clone()\n        .subtract(value, \"milliseconds\")\n        .hours(hours)\n        .minutes(minutes)\n\n      commitShift?.(now.diff(past))\n    })\n\n    callbacks.current.dateChange = vibrateDecorator((newValue: Date | null) => {\n      if (!newValue) return\n      const now = moment()\n      const ref = moment().subtract(value, \"milliseconds\")\n      const past = moment(newValue)\n        .hours(ref.hours())\n        .minutes(ref.minutes())\n        .seconds(ref.seconds())\n        .milliseconds(ref.milliseconds())\n\n      commitShift?.(now.diff(past))\n    })\n  }, [props.value, props.onChange])\n\n  const contentShift = scrollShift != null ? scrollShift : props.value\n  const date = moment(new Date(current - contentShift))\n\n  let minRangeRounded = current - MAX_LENGTH * 1000\n  minRangeRounded -= minRangeRounded % (60 * 1000)\n\n  let maxRangeRounded = current\n  maxRangeRounded += 60 * 1000 - (maxRangeRounded % (60 * 1000))\n\n  const minDate = moment(new Date(minRangeRounded))\n  const maxDate = moment(new Date(maxRangeRounded))\n\n  return (\n    <div\n      className={styles.main}\n      style={{ opacity: visible ? 1 : 0 }}\n      onTouchStart={show.current}\n      onMouseMove={show.current}\n    >\n      <div className={styles.top}>\n        <NavLink to=\"/\" className={styles.back}>\n          <svg\n            viewBox=\"0 0 29 21\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n          >\n            <path\n              d=\"M25 9.17424V11.8258H9.09091L16.3826 19.1174L14.5 21L4 10.5L14.5 0L16.3826 1.88258L9.09091 9.17424H25Z\"\n              fill=\"currentColor\"\n            />\n          </svg>\n        </NavLink>\n        <div className={styles.info}>\n          <span\n            className={styles.color}\n            style={{ backgroundColor: props.stream?.color }}\n          ></span>\n          <span className={styles.name}>{props.stream?.name}</span>\n        </div>\n      </div>\n      <div className={styles.timeline}>\n        <div className={styles.center}>\n          <div className={styles.timewrapper}>\n            <div\n              onClick={() => callbacks.current.sliderChange?.(0)}\n              className={styles.timeoffset}\n            >\n              {!contentShift ? (\n                <span className={styles.live}>Živě</span>\n              ) : (\n                formatTime(-contentShift)\n              )}\n            </div>\n\n            <div className={[styles.pill, styles.margin].join(\" \")}>\n              <input\n                className={styles.cover}\n                onChange={(e) => callbacks.current.timeChange?.(e.target.value)}\n                value={date.format(\"HH:mm\")}\n                min={minDate.format(\"HH:mm\")}\n                max={maxDate.format(\"HH:mm\")}\n                type=\"time\"\n              />\n              <span className={styles.time}>\n                {date.format(\"HH:mm:ss\")}\n              </span>\n            </div>\n          </div>\n          <div className={styles.pill}>\n            <input\n              className={styles.cover}\n              onChange={(e) =>\n                callbacks.current.dateChange?.(e.target.valueAsDate)\n              }\n              value={date.format(\"YYYY-MM-DD\")}\n              min={minDate.format(\"YYYY-MM-DD\")}\n              max={maxDate.format(\"YYYY-MM-DD\")}\n              type=\"date\"\n            />\n            <span className={styles.calendar}>\n              {date.format(\"DD. MMMM YYYY\")}\n            </span>\n          </div>\n        </div>\n      </div>\n      <Slider\n        onScroll={setScrollShift}\n        onScrollEnd={callbacks.current.sliderChange}\n        value={props.value}\n        color={props.stream.color}\n      />\n    </div>\n  )\n}\n","/** @jsxImportSource @emotion/react */\nimport { Component } from \"react\"\n\nimport { HLSPlayer } from \"components/HLSPlayer\"\nimport { Scrobber } from \"components/Scrobber/Scrobber\"\n\nimport { API_URL } from \"utils/constants\"\nimport { css } from \"@emotion/react\"\n\ntype Props = {\n  name: string\n  streams: {\n    key: string\n    name: string\n    color: string\n  }[]\n}\n\ntype State = {\n  from: number\n  to: number\n  shift: number\n  showTools: boolean\n}\n\nexport default class Camera extends Component<Props, State> {\n  state: State = {\n    from: 0,\n    to: 0,\n    shift: 0,\n    showTools: false,\n  }\n\n  generateUrl = ({\n    name,\n    from,\n    to,\n    shift,\n  }: {\n    name: string\n    from: number\n    to: number\n    shift: number\n  }): string | null => {\n    let baseUrl = `${API_URL}/data/${name}/`\n    let type = \"stream.m3u8\"\n\n    let params = []\n    if (from > 0) {\n      type = \"slice.m3u8\"\n      params.push(`from=${from}`)\n\n      if (to > 0 && from < to) {\n        params.push(`to=${to}`)\n      }\n    } else if (shift > 0) {\n      params.push(`shift=${Math.ceil(shift / 1000)}`)\n    }\n\n    baseUrl += type\n    if (params.length > 0) {\n      baseUrl += \"?\" + params.join(\"&\")\n    }\n\n    return baseUrl\n  }\n\n  componentWillUpdate(newProps: Props) {\n    if (this.props.name !== newProps.name) {\n      this.setState({ from: 0, to: 0, shift: 0 })\n    }\n  }\n\n  render() {\n    const { name, streams } = this.props\n    const { from, to, shift } = this.state\n    const url = this.generateUrl({ name, from, to, shift })\n\n    const stream = streams.find(({ key }) => key === name)\n\n    return (\n      <div\n        css={css`\n          display: flex;\n          align-items: center;\n          justify-content: center;\n\n          position: absolute;\n          top: 0;\n          right: 0;\n          bottom: 0;\n          left: 0;\n\n          background: #090909;\n\n          & > video {\n            width: 100%;\n            height: 100%;\n            object-fit: contain;\n            object-position: center;\n          }\n        `}\n      >\n        {url && <HLSPlayer source={url} />}\n        {stream && (\n          <Scrobber\n            onChange={(shift) => this.setState({ shift })}\n            value={shift}\n            stream={stream}\n          />\n        )}\n      </div>\n    )\n  }\n}\n","import React, { useState, useEffect } from \"react\"\nimport {\n  BrowserRouter as Router,\n  Route,\n  RouteComponentProps,\n} from \"react-router-dom\"\n\nimport Home from \"./routes/Home/Home\"\nimport Camera from \"./routes/Camera/Camera\"\n\nimport { API_URL, COLORS } from \"./utils/constants\"\nimport DataContext from \"./utils/dataProvider\"\n\nexport default function App() {\n  const [streams, setStreams] = useState([])\n\n  useEffect(() => {\n    fetch(`${API_URL}/streams`)\n      .then((a) => a.json())\n      .then(({ data }) =>\n        setStreams(\n          data.map((item: any, index: number) => ({\n            ...item,\n            color: COLORS[index % COLORS.length],\n          }))\n        )\n      )\n  }, [])\n\n  return (\n    <Router>\n      <DataContext.Provider value={{ streams }}>\n        <div id=\"app\">\n          <Route exact path=\"/\" component={Home} />\n          <Route\n            path=\"/camera/:name\"\n            render={({ match }: RouteComponentProps<{ name: string }>) => (\n              <Camera name={match.params.name} streams={streams} />\n            )}\n          />\n        </div>\n      </DataContext.Provider>\n    </Router>\n  )\n}\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport \"./index.css\"\nimport App from \"./App\"\n\nReactDOM.render(<App />, document.getElementById(\"root\"))\n"],"sourceRoot":""}